\section{Implementation}
\label{implementation}

A library implementing both the classic and covering LSH schemes has been developed in order to facilitate an experimental evaluation of the two. The library has been released as open-source software and is available at \url{https://github.com/kasperisager/hemingway}. C++ was chosen as the implementation language as it balances performance with higher-level constructs that help ensure a safe and succint implementation. The library is fairly simple in that it only exposes two classes: One for representing bit vectors and one for representing the actual LSH data structure.

\paragraph{Vector} The vector class provides an efficient bit vector representation that allows for arbitraily large dimensionsality by storing bit components in a variable number of 32-bit unsigned integer chunks. This representation effectively supports all the operations needed by the LSH schemes:

\begin{itemize}
  \item Random access in $O(1)$
  \item Distance computing in $O(c)$
  \item Equality checking in $O(c)$
  \item Dot product computing in $O(c)$
  \item Bitwise AND in $O(c)$
  \item Hash computing in $O(c)$
\end{itemize}

Here $c$ denotes the number of component chunks in a vector. The time complexity of each operation has been listed in order to justify the comparision between the two LSH schemes; as can be seen, no vector operation poses a bottleneck for neither scheme.

It is assumed in \cite{DBLP:journals/corr/Pagh15} that population counts, i.e. the number of 1s in a set of bits, can be counted in $O(1)$. The \texttt{\_\_builtin\_popcount}\footnote{\url{https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html}} intrinsic supports this and is used in the library, hence complexity $O(c)$ of the distance, equality, dot product, and AND operations.

\paragraph{Table} The table class provides a representation of the LSH data structure itself and is initialized by supplying a configuration for either the classic or covering LSH scheme. In the case of classic LSH, the width of vector hashes and the number of partitions to use are specified. In the case of covering LSH, the radius to cover is specified.

Once configured, vectors can be inserted into the table using an API similar to that of most data structures in the C++ standard library. Query operations can then be performed against the table once filled with data.

The table consists of several partitions, each represented as an unordered mapping from hashed vectors to buckets. When adding a vector to the table, this vector is first stored in a list in the table. The index of this vector is then stored in an associated bucket in each of the different partitions in order to avoid copying the vector to each partition. The vector hash used for associating a vector with a bucket is constructed differently depending on the configured LSH scheme, but this is in essence the only functional difference between the different schemes.

When configuring the table, the notion of the approximation factor, $c$, and the radius to a nearest neighbour, $r$, is completely left out. The onus of picking parameters appropriate for a given input set and use case is therefore on the client of the library.
